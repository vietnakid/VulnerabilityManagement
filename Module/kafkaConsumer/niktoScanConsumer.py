# Standard library imports
import json
import threading
import logging
import time

# Third party imports
from kafka import KafkaConsumer

# Local application imports
from Config.config import NiktoAgents, KafkaTopicNames, KafkaConfig, KafkaGroupIds
from Module.AgentCaller.niktoCaller import NiktoCaller

class NiktoScanConsumers(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.consumer = KafkaConsumer(
                        KafkaTopicNames.NIKTOSCAN,
                        bootstrap_servers       = KafkaConfig.BOOTSTRAPSERVER,
                        auto_offset_reset       = 'earliest',
                        enable_auto_commit      = False,
                        session_timeout_ms      = NiktoAgents.SESSION_TIMEOUT_MS,
                        max_poll_records        = 1,
                        max_poll_interval_ms    = NiktoAgents.MAX_POLL_INTERVAL_MS,
                        group_id                = KafkaGroupIds.NIKTOSCAN,
                        value_deserializer      = lambda x: json.loads(x.decode('utf-8')))
        self.niktoAgentsAddress = NiktoAgents.NIKTO_AGENT_ADDRESS
        self.totalAgent = len(self.niktoAgentsAddress)
        self.curAgentIndex = 0
        self.logger = logging.getLogger(__name__)

        self.currentRunningThread = [set() for _ in range(self.totalAgent)]

    def run(self):
        try:
            while True:
                msg_pack = self.consumer.poll(timeout_ms=2000)
                for message in msg_pack.items():
                    for consumer_record in message[1]:
                        data = consumer_record.value
                        self.logger.info('Recieved {}'.format(data))

                        openports_http = data.get('openports_http')
                        openports_https = data.get('openports_https')
                        niktoData = data
                        if 'openports_http' in niktoData:
                            del niktoData['openports_http']
                        if 'openports_https' in niktoData:
                            del niktoData['openports_https']

                        for port in openports_http:
                            niktoData['target_url'] = "http://" + niktoData.get('target') + ":" + port
                            niktoData['portScanned'] = port
                            while True:
                                niktoAgentAddress = self.niktoAgentsAddress[self.curAgentIndex]
                                isMessageHandled = False
                                assignedIndex = -1

                                if self.isAgentCanScan(self.curAgentIndex):
                                    niktoCaller = NiktoCaller(niktoAgentAddress.get('HOST'), niktoAgentAddress.get('PORT'), niktoData)
                                    niktoCaller.start()
                                    self.currentRunningThread[self.curAgentIndex].add(niktoCaller)

                                    isMessageHandled = True
                                    assignedIndex = self.curAgentIndex

                                self.curAgentIndex = (self.curAgentIndex + 1) % self.totalAgent

                                if isMessageHandled:
                                    self.consumer.commit()
                                    self.logger.info('{} is sent to agent [{}] -- its current running [{}] scans'.format(data, niktoAgentAddress, len(self.currentRunningThread[assignedIndex])))
                                    break

                                if self.curAgentIndex == 0:
                                    self.logger.info('All Nikto_Agent are busy.. sleep for {} seconds'.format(NiktoAgents.THREAD_SLEEP_SECOND))
                                    time.sleep(NiktoAgents.THREAD_SLEEP_SECOND)
                        
                        for port in openports_https:
                            niktoData['target_url'] = "https://" + niktoData.get('target') + ":" + port
                            niktoData['portScanned'] = port
                            while True:
                                niktoAgentAddress = self.niktoAgentsAddress[self.curAgentIndex]
                                isMessageHandled = False
                                assignedIndex = -1

                                if self.isAgentCanScan(self.curAgentIndex):
                                    niktoCaller = NiktoCaller(niktoAgentAddress.get('HOST'), niktoAgentAddress.get('PORT'), niktoData)
                                    niktoCaller.start()
                                    self.currentRunningThread[self.curAgentIndex].add(niktoCaller)

                                    isMessageHandled = True
                                    assignedIndex = self.curAgentIndex

                                self.curAgentIndex = (self.curAgentIndex + 1) % self.totalAgent

                                if isMessageHandled:
                                    self.consumer.commit()
                                    self.logger.info('{} is sent to agent [{}] -- its current running [{}] scans'.format(data, niktoAgentAddress, len(self.currentRunningThread[assignedIndex])))
                                    break

                                if self.curAgentIndex == 0:
                                    self.logger.info('All Nikto_Agent are busy.. sleep for {} seconds'.format(NiktoAgents.THREAD_SLEEP_SECOND))
                                    time.sleep(NiktoAgents.THREAD_SLEEP_SECOND)
        except:
            self.logger.exception("Thread " + __name__ + " terminated")

    def isAgentCanScan(self, curAgentIndex):
        # TODO: check if we can ping to the host or not.
        try:
            MAX_THREAD_PER_AGENT = NiktoAgents.MAX_SCAN_PER_AGENT

            total = 0
            for thread in self.currentRunningThread[curAgentIndex].copy():
                if thread.is_alive():
                    total += 1
                else:
                    self.currentRunningThread[curAgentIndex].remove(thread)

            return total < MAX_THREAD_PER_AGENT
        except:
            self.logger.exception("Thread " + __name__ + " have some error")
            return False


            

 