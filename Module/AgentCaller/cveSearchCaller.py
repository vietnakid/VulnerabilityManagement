# Standard library imports
import json
import threading
import logging
import time
import asyncio
import socket
import itertools

# Third party imports
import requests
import aiohttp
from aiohttp import ClientSession

# Local application imports
from Module.kafkaProducer.cveSearchOutputProducer import CVESeachOutputProducers
from Config.config import CVESearchConfig

class CVESearchCaller(threading.Thread):
    def __init__(self, data):
        threading.Thread.__init__(self)
        self.data = data
        self.logger = logging.getLogger(__name__)
        self.HOST = CVESearchConfig.CVESEARCH_ADDRESS
        self.PORT = CVESearchConfig.CVESEARCH_PORT

    def scanWithAsyncIO(self, cpes):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        result_cpes = loop.run_until_complete(self.request_all_vuls(cpes))
        loop.close()

        return result_cpes

    def scanWithSocket(self, cpes):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.connect((self.HOST, self.PORT))
                data = {'cpes': cpes}
                jData = json.dumps(data) + '\n'
                s.sendall(jData.encode('utf-8'))
                jOutputData = b''
                while True:
                    _data = s.recv(1024)
                    if not _data:
                        break
                    jOutputData += _data
            
            try: # CVESearch agents can send invalid data
                outputData = json.loads(jOutputData.decode('utf-8'))
                
                return outputData
            except:
                self.logger.exception("There are something wrong with return data from Cve_Search Agent for target= {}: Recived data = {}".format(self.data, jOutputData))
                return {}
        except:
            self.logger.exception("Something wrong when connect to cveSearch host at: " + str(self.HOST) + ":" + str(self.PORT))
            return {}

    def run(self):
        result = {}
        result["target"] = self.data.get("target")
        result["hostname"] = self.data.get("hostname")
        cpes = self.data.get('cpes')
        _startTime = int(time.time())

        result["weakness"] = {}

        if self.data.get("source") == "nmapOutput":
            weakness = self.scanWithAsyncIO(cpes)
            result["weakness"] = list(itertools.chain.from_iterable(weakness))
        elif self.data.get("source") == "wappalyzerOutput":
            result["weakness"] = self.scanWithSocket(cpes)
            
        scan_stat = dict()
        scan_stat['startTime'] = _startTime
        scan_stat["endTime"] = int(time.time())
        scan_stat["duration"] = (scan_stat["endTime"] - scan_stat["startTime"])

        result['root_scan_id'] = self.data.get('root_scan_id')
        result['scan_type'] = self.data.get('scan_type')
        result['scan_id'] = self.data.get('scan_id')
        result['source'] = self.data.get("source")
        result["scanstat"] = scan_stat

        cveSearchOutputProducer = CVESeachOutputProducers()
        cveSearchOutputProducer.sendDataToQueue(result)    

    async def request_all_vuls(self, cpes):
        async with aiohttp.ClientSession() as session:
            tasks = []
            for cpe in cpes:
                tasks.append(self.sendRequest(session, cpe))
            return await asyncio.gather(*tasks, return_exceptions=True)

    async def sendRequest(self, session, cpe): 
        try:
            url = CVESearchConfig.URL + CVESearchConfig.API_CVEFOR + cpe
            async with session.get(url) as response:
                response = await response.json()
                result = []
                for res in response:
                    cve = {}
                    cve["cvss"] = float(res.get("cvss"))
                    cve["cwe"] = res.get("cwe")
                    cve["cve"] = res.get("id")
                    cve["cpe"] = cpe
                    result.append(cve)
                return result
        except:
            self.logger.exception()
            return []

        


